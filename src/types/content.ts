/**
 * content.ts - TypeScript Types for Content Generation System
 *
 * This file defines all TypeScript interfaces and types related to the
 * AI content generation system powered by n8n workflows.
 *
 * WHAT IS THIS SYSTEM?
 * The app sends user preferences to an n8n webhook, which triggers an
 * AI workflow to generate personalized learning content. The content
 * is then written to Firestore, and the app receives it via a real-time
 * listener.
 *
 * ARCHITECTURE FLOW:
 * 1. App sends POST to n8n webhook (ContentRequest)
 * 2. n8n processes asynchronously, generates content with AI
 * 3. n8n writes result to Firestore (GeneratedContent)
 * 4. App's Firestore listener receives content in real-time
 * 5. Content displays in the app
 *
 * WHY SEPARATE TYPES FILE?
 * - Single source of truth for content-related types
 * - Avoids circular dependencies between services and slices
 * - Makes types easily importable from anywhere
 * - Documents the data structure clearly
 */

/**
 * =============================================================================
 * WEBHOOK REQUEST TYPES
 * =============================================================================
 *
 * These types define the payload structure sent to the n8n webhook.
 */

/**
 * ContentRequest Interface
 *
 * The payload sent to the n8n webhook to trigger content generation.
 * This is what the app POSTs to n8n when requesting new content.
 *
 * FIELDS:
 * - userId: Firebase Auth UID to identify the user
 * - displayName: User's name for personalization in content
 * - categories: Array of topics the user wants to learn about
 * - dailyLearningMinutes: How much time the user has to read
 * - contentHistory: Previous topic summaries to avoid repetition
 * - requestId: Unique ID to track this specific request
 * - timestamp: When the request was made (ISO string)
 *
 * EXAMPLE:
 * {
 *   userId: "abc123",
 *   displayName: "John",
 *   categories: ["technology", "custom:blockchain"],
 *   dailyLearningMinutes: 15,
 *   contentHistory: ["Electric car batteries", "Quantum computing basics"],
 *   requestId: "uuid-v4-here",
 *   timestamp: "2024-01-15T10:30:00.000Z"
 * }
 */
export interface ContentRequest {
  userId: string;
  displayName: string;
  categories: string[];
  dailyLearningMinutes: number;
  contentHistory: string[];
  requestId: string;
  timestamp: string;
}

/**
 * =============================================================================
 * GENERATED CONTENT TYPES
 * =============================================================================
 *
 * These types define the structure of content written by n8n to Firestore.
 */

/**
 * ContentSource Interface
 *
 * Represents a source/reference used by the AI when generating content.
 * Optional field that provides credibility and allows users to dive deeper.
 */
export interface ContentSource {
  title: string;
  url: string;
}

/**
 * ContentBody Interface
 *
 * The actual content generated by AI.
 * This is nested inside GeneratedContent when status is "completed".
 *
 * FIELDS:
 * - title: Catchy headline for the content
 * - summary: 2-3 sentence hook to engage the reader
 * - body: Full article content (supports markdown formatting)
 * - readingTimeMinutes: Estimated time to read
 * - category: Primary category this content belongs to
 * - sources: Optional array of references used
 *
 * MARKDOWN SUPPORT:
 * The body field can contain markdown formatting:
 * - Headers (##, ###)
 * - Bold (**text**)
 * - Italics (*text*)
 * - Lists (-, *)
 * - Links ([text](url))
 * - Code blocks (```)
 */
export interface ContentBody {
  title: string;
  summary: string;
  body: string;
  readingTimeMinutes: number;
  category: string;
  sources?: ContentSource[];
}

/**
 * ContentStatus Type
 *
 * The possible states of a content generation request.
 *
 * - pending: Request received, AI is processing
 * - completed: Content generated successfully
 * - error: Something went wrong during generation
 */
export type ContentStatus = 'pending' | 'completed' | 'error';

/**
 * GeneratedContent Interface
 *
 * The document structure written by n8n to Firestore.
 * Stored at: users/{userId}/generatedContent/{requestId}
 *
 * LIFECYCLE:
 * 1. n8n creates document with status: "pending" (optional)
 * 2. AI generates content
 * 3. n8n updates document with status: "completed" and content
 * OR
 * 3. If error, n8n sets status: "error" with error message
 *
 * FIELDS:
 * - requestId: Links back to the original request
 * - status: Current state of content generation
 * - content: The actual content (only when completed)
 * - topicSummary: Brief summary for content history (max 100 chars)
 * - generatedAt: When the content was created
 * - error: Error message if status is "error"
 */
export interface GeneratedContent {
  requestId: string;
  status: ContentStatus;
  content?: ContentBody;
  topicSummary?: string;
  /**
   * ISO 8601 string representing when the content was generated.
   * We use string instead of Date because Redux requires serializable values.
   * Example: "2024-01-15T10:30:00.000Z"
   */
  generatedAt: string | null;
  error?: string;
}

/**
 * =============================================================================
 * CONTENT HISTORY TYPES
 * =============================================================================
 *
 * These types support the anti-repetition system.
 * Content history tracks what topics have been shown to prevent duplicates.
 */

/**
 * ContentHistoryEntry Interface
 *
 * A record of content that was shown to the user.
 * Stored at: users/{userId}/contentHistory/{historyId}
 *
 * PURPOSE:
 * - Prevents AI from generating repetitive content
 * - Tracks user engagement (viewed, saved)
 * - Provides data for content recommendations
 *
 * FIELDS:
 * - id: Firestore document ID (optional, added after fetch)
 * - requestId: Links to the content request
 * - topicSummary: Brief description (max 100 chars) for AI context
 * - category: Primary category
 * - generatedAt: When the content was generated
 * - viewed: Did the user actually read this content?
 * - saved: Did the user bookmark this content?
 *
 * HOW IT'S USED:
 * When requesting new content, we fetch the last 20 entries and send
 * their topicSummary values to n8n. The AI uses these to avoid
 * generating similar content.
 */
export interface ContentHistoryEntry {
  id?: string;
  requestId: string;
  topicSummary: string;
  category: string;
  /**
   * ISO 8601 string representing when the content was generated.
   * We use string instead of Date because Redux requires serializable values.
   */
  generatedAt: string;
  viewed: boolean;
  saved: boolean;
  /**
   * ISO 8601 string representing when the user actually read the content.
   * This is set when the user marks content as viewed (dismisses after reading).
   * Used for calculating weekly read count (streak).
   *
   * WHY SEPARATE FROM generatedAt?
   * - generatedAt: When AI created the content
   * - viewedAt: When user actually read/dismissed it
   * The weekly count should track reading activity, not generation time.
   */
  viewedAt?: string;
}

/**
 * =============================================================================
 * REDUX STATE TYPES
 * =============================================================================
 *
 * These types define the shape of the content Redux slice.
 */

/**
 * ContentState Interface
 *
 * The complete state shape for the content slice in Redux.
 *
 * FIELDS:
 * - pendingRequestId: ID of request waiting for response (null if none)
 * - isLoading: True while waiting for content generation
 * - currentContent: The content currently being displayed
 * - contentQueue: Multiple pieces of content waiting to be shown
 * - contentHistory: Recent history entries for anti-repetition
 * - error: Error message if something went wrong
 * - lastFetchedAt: When content was last successfully received
 *
 * STATE TRANSITIONS:
 *
 * Initial state:
 * { pendingRequestId: null, isLoading: false, currentContent: null, ... }
 *
 * After requesting content:
 * { pendingRequestId: "uuid", isLoading: true, currentContent: null, ... }
 *
 * After receiving content:
 * { pendingRequestId: null, isLoading: false, currentContent: {...}, ... }
 *
 * On error:
 * { pendingRequestId: null, isLoading: false, error: "...", ... }
 */
export interface ContentState {
  pendingRequestId: string | null;
  isLoading: boolean;
  currentContent: GeneratedContent | null;
  contentQueue: GeneratedContent[];
  contentHistory: ContentHistoryEntry[];
  error: string | null;
  /**
   * ISO 8601 string representing when content was last fetched.
   * We use string instead of Date because Redux requires serializable values.
   */
  lastFetchedAt: string | null;
}

/**
 * =============================================================================
 * RECENT ARTICLES TYPES
 * =============================================================================
 *
 * These types support the "Recent Articles" widget on the home screen.
 * Recent articles are the last 3 articles the user has engaged with.
 */

/**
 * RecentArticle Interface
 *
 * Represents an article in the user's recent reading history.
 * Stored at: users/{userId}/recentArticles/{docId}
 *
 * PURPOSE:
 * - Provides quick access to recently read content
 * - Shows a compact preview on the home screen
 * - Maximum 3 articles stored (oldest deleted when new one added)
 *
 * FIELDS:
 * - id: Firestore document ID (added after fetch)
 * - contentBody: Full article content (denormalized for fast reads)
 * - readAt: When the user finished reading this article
 * - createdAt: When this recent article entry was created
 *
 * WHY STORE FULL CONTENT?
 * Unlike a reference-based approach, we store the full ContentBody because:
 * 1. Articles are AI-generated on-the-fly, not stored in a master collection
 * 2. 3 articles is trivially small (~10-15KB total)
 * 3. Single read = complete data, no additional queries needed
 * 4. Content persists even if the original generated content is deleted
 *
 * WIDGET DISPLAY:
 * On the home screen, this displays as:
 * - Title (from contentBody.title)
 * - One line preview (from contentBody.summary, truncated)
 * Tapping opens the full ContentFullView with complete article.
 */
export interface RecentArticle {
  id?: string;
  contentBody: ContentBody;
  /**
   * ISO 8601 string representing when the user finished reading.
   * This determines the order in the "Recent" list (newest first).
   */
  readAt: string;
  /**
   * ISO 8601 string representing when this entry was created.
   * Usually same as readAt, but kept separate for clarity.
   */
  createdAt: string;
}

/**
 * =============================================================================
 * SERVICE RESPONSE TYPES
 * =============================================================================
 *
 * Types for service function return values.
 */

/**
 * TriggerContentResult Interface
 *
 * Return type for the triggerContentGeneration service function.
 * Indicates whether the webhook call succeeded.
 */
export interface TriggerContentResult {
  requestId: string;
  success: boolean;
  error?: string;
}

/**
 * =============================================================================
 * LEARNING NOTES
 * =============================================================================
 *
 * 1. TYPE COMPOSITION
 *    We break down complex types into smaller pieces:
 *    - ContentSource is used inside ContentBody
 *    - ContentBody is used inside GeneratedContent
 *    This makes each type focused and reusable.
 *
 * 2. OPTIONAL FIELDS
 *    The ? after a field name means it's optional:
 *    - content?: ContentBody - Only present when status is "completed"
 *    - error?: string - Only present when status is "error"
 *    This models the real data structure accurately.
 *
 * 3. UNION TYPES
 *    ContentStatus = 'pending' | 'completed' | 'error'
 *    This ensures status can only be one of these three values.
 *    TypeScript will error if you try to use anything else.
 *
 * 4. DATE/TIMESTAMP HANDLING (IMPORTANT FOR REDUX!)
 *    We use ISO 8601 strings (not Date objects) for timestamps:
 *    - string when we have a value: "2024-01-15T10:30:00.000Z"
 *    - null when the document is first created
 *
 *    WHY STRINGS INSTEAD OF DATE OBJECTS?
 *    Redux requires all state values to be "serializable" - meaning they
 *    can be converted to JSON and back. Date objects are NOT serializable
 *    because JSON.stringify(new Date()) gives a string, but JSON.parse()
 *    returns that string, not a Date object.
 *
 *    Using ISO strings solves this:
 *    - Redux DevTools work correctly
 *    - State persistence (AsyncStorage) works
 *    - Time travel debugging works
 *    - Convert to Date when needed: new Date(isoString)
 *
 * 5. FIRESTORE DOCUMENT STRUCTURE
 *    These types mirror the Firestore document structure:
 *    - users/{userId}/generatedContent/{requestId} → GeneratedContent
 *    - users/{userId}/contentHistory/{historyId} → ContentHistoryEntry
 *    Keeping types aligned with data structure prevents bugs.
 *
 * 6. SEPARATION OF CONCERNS
 *    - ContentRequest: What we SEND to n8n
 *    - GeneratedContent: What we RECEIVE from n8n via Firestore
 *    - ContentState: How we STORE it in Redux
 *    Each type has a specific purpose in the data flow.
 */
